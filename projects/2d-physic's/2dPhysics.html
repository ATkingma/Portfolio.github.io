<!DOCTYPE html>
<html lang="en">
  <head>
    <meta
      http-equiv="Content-Security-Policy"
      content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://www.googletagmanager.com;
  style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
  img-src 'self' data:;
  font-src 'self' https://cdnjs.cloudflare.com;
  connect-src 'self' https://www.google-analytics.com;
  object-src 'none';
  base-uri 'self';
  form-action 'self';
"
    />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta
      name="permissions-policy"
      content="geolocation=(), microphone=(), camera=()"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>project page - Timme Kingma</title>
    <link rel="icon" type="image/png" href="img/icons/websiteIcon.png" />

    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-B6PLVTBJ0Y"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-B6PLVTBJ0Y");
    </script>

    <link rel="stylesheet" href="../../css/site.css" />
    <link rel="stylesheet" href="../../css/skills.css" />
    <link rel="stylesheet" href="../../css/project-page.css" />
    <link rel="stylesheet" href="../../css/tooltips.css" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <script type="module" src="../../webcomponents/footer.js"></script>
  </head>
  <body>
    <section id="home"></section>
    <div class="nav-container" id="navContainer">
      <button
        class="nav-toggle"
        id="hamburgerTogle"
        aria-label="Toggle navigation"
        aria-expanded="false"
      >
        ☰
      </button>
      <nav class="nav-bar" aria-label="Main navigation">
        <a class="nav-item" href="../../index.html" aria-label="Home">Home </a>
        <a class="nav-item" href="../../about-me.html" aria-label="About me"
          >About me</a
        >
        <a class="nav-item" href="../../links.html" aria-label="Links">Links</a>
      </nav>
    </div>
    <script type="module" src="javascript/hamburger.js"></script>
    <div class="container">
      <!-- Header Section -->
      <div class="header">
        <h1 class="project-title">2D Physics Simulation</h1>
        <div class="tags">
          <span class="tag">Java</span>
          <span class="tag">Physics</span>
          <span class="tag">Collision Detection</span>
        </div>
        <a
          href="https://gitlab.com/ATkingma/2d-physics"
          target="_blank"
          class="github-button"
        >
          View on Gitlab
        </a>
      </div>

      <div class="overview-container">
        <img
          src="img/physics.gif"
          alt="System Architecture"
          class="overview-img"
        />
      </div>
      <!-- General Info Box -->
      <div class="info-box">
        <h2>Project Overview</h2>
        <p>
          This project is a basic 2D physics simulation written in Java. It
          features a custom physics engine with real-time collision detection
          and response between simple shapes, such as circles and rectangles.
          The simulation demonstrates fundamental concepts in physics and
          computational geometry, and visualizes how objects interact in a 2D
          environment.
        </p>
        <p>
          The main goal of this project is to deepen the understanding of game
          physics and the implementation of efficient collision detection
          algorithms, which are essential for realistic interactions in games
          and simulations. The codebase is modular and clearly documented,
          making it an excellent learning resource for anyone interested in game
          development or physics programming.
        </p>
      </div>

      <!-- More Info Box -->
      <div class="info-box">
        <h2>Collision Detection in Practice</h2>
        <p>
          The engine checks for collisions between objects every frame. For
          circles, it uses the distance between centers; for rectangles, it uses
          axis-aligned bounding box (AABB) checks. When a collision is detected,
          the engine calculates the overlap and applies a response so the
          objects bounce off each other realistically.
        </p>
        <p>
          This approach allows for fast and accurate detection, making it
          suitable for real-time applications like games or interactive demos.
        </p>
      </div>

      <!-- Theory Section with Images -->
      <div class="info-box">
        <h2>Theory: How Collision Detection Works</h2>
        <div class="theory-content">
          <div class="theory-item">
            <h3>AABB Collision</h3>
            <a
              href="https://en.wikipedia.org/wiki/Minimum_bounding_box"
              target="_blank"
            >
              <img
                src="img/AABBDetection.png"
                alt="AABB Collision"
                class="theory-img-hover"
              />
            </a>
            <p>
              <strong>Rectangle (AABB) vs. Rectangle:</strong> Two rectangles
              collide if their projections on both the X and Y axes overlap.
              This is known as
              <strong>Axis-Aligned Bounding Box (AABB)</strong> collision
              detection. AABB is very fast because it only requires comparing
              the min and max values of the rectangles on each axis. It works
              best for rectangles that are not rotated.
            </p>
            <div class="code-accordion-item">
              <div class="code-accordion-header">
                <span>PseudoCode</span>
                <span class="code-accordion-icon">⮞</span>
              </div>
              <div class="code-accordion-content">
                <pre><code>
collision: just compare min/max on X and Y
  boolean aabbCollide(Rect a, Rect b) {
    return a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y;
  }
            </code></pre>
              </div>
            </div>
          </div>

          <div class="theory-item">
            <h3>SAT Collision</h3>
            <a
              href="https://en.wikipedia.org/wiki/Hyperplane_separation_theorem"
              target="_blank"
            >
              <img
                src="img/SATDetection.png"
                alt="SAT Collision"
                class="theory-img-hover"
              />
            </a>
            <p>
              <strong>SAT (Separating Axis Theorem):</strong> SAT is a more
              advanced algorithm that can detect collisions between any convex
              polygons, including rotated rectangles. It works by projecting the
              shapes onto potential separating axes and checking for overlaps.
              If a separating axis is found where the projections do not
              overlap, the shapes are not colliding. SAT is more flexible but
              also more computationally expensive than AABB.
            </p>
            <div class="code-accordion-item">
              <div class="code-accordion-header">
                <span>Pseudocode </span>
                <span class="code-accordion-icon">⮞</span>
              </div>
              <div class="code-accordion-content">
                <pre><code>
collision:
  boolean satCollide(Polygon polyA, Polygon polyB) {
    for (Vector axis : getAxes(polyA, polyB)) {
      Projection projA = project(polyA, axis);
      Projection projB = project(polyB, axis);
      if (!projA.overlaps(projB)) {
        return false; // Found a separating axis
      }
    }
    return true; // No separating axis, collision!
  }
            </code></pre>
              </div>
            </div>
          </div>

          <div class="theory-item">
            <h3>Circle Collision</h3>
            <a
              href="https://www.jeffreythompson.org/collision-detection/circle-circle.php"
              target="_blank"
            >
              <img
                src="img/CircleDetection.png"
                alt="Circle Collision"
                class="theory-img-hover"
              />
            </a>
            <p>
              <strong>Circle vs. Circle:</strong> Two circles collide if the
              distance between their centers is less than the sum of their
              radii. This is calculated using the Pythagorean theorem.
            </p>
          </div>
        </div>
      </div>
     <div class="info-box">
                <h2>How SAT and AABB Are Used Together</h2>
                <p>
                  In this project, <strong>SAT (Separating Axis Theorem)</strong> is used for accurate collision detection between all shapes, including rotated rectangles and polygons. SAT determines if two objects will collide by checking for a separating axis between them.
                </p>
                <p>
                  Once a collision is detected with SAT, <strong>AABB (Axis-Aligned Bounding Box)</strong> logic is used to calculate the collision resolution, specifically, to determine the separation axis and penetration depth for resolving overlaps. This approach combines the accuracy of SAT for detection with the simplicity and efficiency of AABB for resolving collisions, especially for axis-aligned objects.
                </p>
                <p>
                  This method ensures that the simulation is both robust (able to handle complex shapes) and efficient (fast resolution for common cases), matching the real implementation in the code.
                </p>
              </div>

      <!-- Modern accordion with Prism auto-detect for Java and C# -->
      <div class="info-box">
          <h2>Code Examples</h2>
          <div class="code-accordion">
            <div class="code-accordion-item">
              <div class="code-accordion-header">
                <span>AABB-like projection (Java)</span>
                <span class="code-accordion-icon">⮞</span>
              </div>
              <div class="code-accordion-content">
                <pre><code class="language-java">
public boolean overlapsOnAxis(Collider other, Vector2 axis) {
    float[] projA = this.projectOntoAxis(axis);
    float[] projB = other.projectOntoAxis(axis);
    return !(projA[1] < projB[0] || projB[1] < projA[0]);
}

public float[] projectOntoAxis(Vector2 axis) {
    ArrayList<Vector2> worldPoints = getWorldPoints();
    if (worldPoints.isEmpty()) {
        return new float[]{0f, 0f};
    }
    
    float min = (float) worldPoints.get(0).dot(axis);
    float max = min;
    
    for (int i = 1; i < worldPoints.size(); i++) {
        float projection = (float) worldPoints.get(i).dot(axis);
        min = Math.min(min, projection);
        max = Math.max(max, projection);
    }
    
    return new float[]{min, max};
}
                </code></pre>
              </div>
            </div>
            <div class="code-accordion-item">
              <div class="code-accordion-header">
                <span>Circle-Circle Collision (Java)</span>
                <span class="code-accordion-icon">⮞</span>
              </div>
              <div class="code-accordion-content">
                <pre><code class="language-java">
public boolean overlapsWithCircle(CircleCollider other) {
    Vector2 thisCenter = this.getObject().futureTransform.position;
    Vector2 otherCenter = other.getObject().futureTransform.position;
    float distance = (float) thisCenter.distance(otherCenter);
    return distance < (this.radius + other.radius);
}
                </code></pre>
              </div>
            </div>
            <div class="code-accordion-item">
              <div class="code-accordion-header">
                <span>SAT Collision(Java, simplified)</span>
                <span class="code-accordion-icon">⮞</span>
              </div>
              <div class="code-accordion-content">
                <pre><code class="language-java">
public boolean intersects(Collider other) {
        if (other == null) {
            return false;
        }
        
        ArrayList<Vector2> axesA = this.getAxes();
        ArrayList<Vector2> axesB = other.getAxes();
        
        if (axesA.isEmpty() || axesB.isEmpty()) {
            return false;
        }
        
        for (Vector2 axis : axesA) {
            if (axis.magnitude() < 0.001f) continue;
            if (!this.overlapsOnAxis(other, axis)) {
                return false;
            }
        }
        
        for (Vector2 axis : axesB) {
            if (axis.magnitude() < 0.001f) continue;
            if (!this.overlapsOnAxis(other, axis)) {
                return false;
            }
        }
        
        return true;
    }
                </code></pre>
              </div>
            </div>
          </div>
        </div>
        
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      // Autoloader path
      Prism.plugins.autoloader.languages_path =
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/";

      // Basic language detection heuristics and initialization
      function detectLanguage(codeText) {
        const text = codeText;
        if (/using\s+System|Console\.WriteLine/.test(text)) return "csharp";
        if (/public\s+class|System\.out|String\s+args/.test(text))
          return "java";
        if (/#include|std::|cout\s*<</.test(text)) return "cpp";
        if (/function\s+|console\.log\(|=>/.test(text)) return "javascript";
        return "";
      }

      document.addEventListener("DOMContentLoaded", function () {
        // Set classes on code blocks based on heuristics
        document
          .querySelectorAll(".code-accordion pre code")
          .forEach((codeEl) => {
            const detected = detectLanguage(codeEl.textContent || "");
            if (detected) codeEl.className = "language-" + detected;
          });

        // Initialize Prism highlight for visible blocks
        Prism.highlightAll();

        // Accordion toggle handlers
        document
          .querySelectorAll(".code-accordion-header")
          .forEach((header) => {
            header.addEventListener("click", function () {
              const item = this.parentElement;
              item.classList.toggle("active");
              // Re-highlight code inside when opened (useful if autoloader loads later)
              if (item.classList.contains("active")) {
                const code = item.querySelector("pre code");
                if (code) Prism.highlightElement(code);
              }
            });
          });
      });
    </script>
    </div>
  <footer-element></footer-element>
  </body>
  </html>
